

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mindaffectBCI.decoder.normalizeOutputScores &mdash; mindaffectBCI - documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> mindaffectBCI
          

          
            
            <img src="../../../_static/MindAffect_Logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../OnlineBCI_quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">mindaffectBCI</a></li>
</ul>
<p class="caption"><span class="caption-text">The headset</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../printing_guide.html">Print Your Own Headset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fitting_guide.html">Setup &amp; fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../headset_layout.html">Headset layout</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mindaffectBCI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mindaffectBCI.decoder.normalizeOutputScores</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mindaffectBCI.decoder.normalizeOutputScores</h1><div class="highlight"><pre>
<span></span><span class="c1">#@function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<div class="viewcode-block" id="normalizeOutputScores"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.normalizeOutputScores.normalizeOutputScores">[docs]</a><span class="k">def</span> <span class="nf">normalizeOutputScores</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">validTgt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">badFyThresh</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                          <span class="n">centFy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detrendFy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                          <span class="n">nEpochCorrection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">minDecisLen</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxDecisLen</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">bwdAccumulate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">priorsigma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    normalize the raw output scores to feed into the Perr computation</span>
<span class="sd">    Inputs:</span>
<span class="sd">      Fy   - (nM,nTr,nEp,nY) [#Y x #Epoch x #Trials x nModels]:float</span>
<span class="sd">      validTgt - (nM,nTr,nY) [ #Y x #Trials x nModels ]:bool indication of which outputs are used in each trial</span>
<span class="sd">      badFyThresh - threshold for detction of bad Fy entry, in std-dev</span>
<span class="sd">      centFy   - bool, do we center Fy before computing  *important*  (true)</span>
<span class="sd">      nEpochCorrection - int, number of epochs to use a base for correction of number epochs in the sum.</span>
<span class="sd">               basically, nEpoch &lt; nEpochCorrection have highly increased Perr, so unlikely to be selected</span>
<span class="sd">      minDecisLen - int, number of epochs to use as base for distribution of time-based decision points.</span>
<span class="sd">                         i.e. decisions at, [1,2,4,...2^n]*exptDistDecis</span>
<span class="sd">                    OR: minDecisLen&lt;0 =&gt; decision point every abs(minDeicsLen) epochs</span>
<span class="sd">      maxDecisLen   - maximum number of epochs for a decision</span>
<span class="sd">      bwdAccumulate - [bool], accumulate data backwards from last epoch gathered</span>
<span class="sd">      prior_sigma (float,float) - prior estimate of the variance and it&#39;s equivalent samples weight (sigma,N)</span>
<span class="sd">    Outputs:</span>
<span class="sd">      ssFy - (nM,nTr,nDecis,nY) [#Y x #decisPts x #Trials x #Models] scaled summed scores</span>
<span class="sd">      sFy_scale - (nM,nTr,nDecis,1) [1 x #decisPts x #Trails x #Models] the normalization scaling factor</span>
<span class="sd">      Nep - (nDecis) [ #decisPts x 1 ] number of epochs included in each score</span>
<span class="sd">      nEp,nY - (nTrl) [ 1 x #Trials ] the detected number epoch/output for each trial</span>
<span class="sd">    Copyright (c) MindAffect B.V. 2018</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">normSum</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">Fy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">Fy</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ssFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">ssFy</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># compress out the model dimension</span>
    <span class="n">Fyshape</span> <span class="o">=</span> <span class="n">Fy</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># (nM,nTrl,nEp,nY)</span>
    <span class="k">if</span> <span class="n">Fy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">Fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="p">)</span><span class="o">+</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span> <span class="c1"># ((nM*nTrl), nEp, nY) [ nY x nEp x (nTrl*nM*..)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">validTgt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> <span class="c1"># (nM, nTr, nY)</span>
            <span class="n">validTgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">validTgt</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">validTgt</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">validTgt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span> <span class="c1"># ((nM*nTrl), nY) [ nY x (nTrl*nM)]</span>
    <span class="k">if</span> <span class="n">Fy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># ensure has trial dim</span>
        <span class="n">Fy</span> <span class="o">=</span> <span class="n">Fy</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="c1"># get info on the number of valid Epochs or Outputs in each trial</span>
    <span class="n">validFy</span> <span class="o">=</span> <span class="n">Fy</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">nY</span><span class="p">,</span> <span class="n">nEp</span><span class="p">,</span> <span class="n">validTgt</span> <span class="o">=</span> <span class="n">get_valid_epochs_outputs</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">validTgt</span><span class="p">)</span>
    <span class="n">maxnEp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nEp</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">maxnEp</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># guard no data to analyse</span>
        <span class="n">ssFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">ssFy</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># estimate the points at which we may make a decision</span>
    <span class="n">decisIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">maxnEp</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># default to single decision at max-length</span>
    <span class="k">if</span> <span class="n">minDecisLen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">minDecisLen</span> <span class="o">&lt;</span> <span class="n">maxnEp</span><span class="p">:</span>
        <span class="c1"># exp-distributed decision points</span>
        <span class="n">nstep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">maxnEp</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">minDecisLen</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">decisIdx</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">minDecisLen</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">decisIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">decisIdx</span><span class="p">,</span> <span class="n">minDecisLen</span><span class="p">),</span> <span class="n">maxnEp</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">minDecisLen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># linearly distributed decision points</span>
        <span class="n">decisIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">minDecisLen</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxnEp</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">minDecisLen</span><span class="p">)</span>
        <span class="n">decisIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decisIdx</span><span class="p">,</span> <span class="n">maxnEp</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="c1"># minDecisLen = 0 -&gt; max-length</span>
        <span class="k">pass</span>
    <span class="c1">#print(&quot;decisIdx={}&quot;.format(decisIdx))</span>

    <span class="c1"># Limit the max window size to test</span>
    <span class="k">if</span> <span class="n">maxDecisLen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">maxDecisLen</span> <span class="o">&gt;=</span> <span class="n">decisIdx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">decisIdx</span> <span class="o">=</span> <span class="n">decisIdx</span><span class="p">[</span><span class="n">decisIdx</span> <span class="o">&lt;=</span> <span class="n">maxDecisLen</span><span class="p">]</span>

    <span class="c1"># For computational efficiency remove data outside the max decision points</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">decisIdx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">100</span><span class="p">):</span> <span class="c1"># (nM, nTrl, nEp, nY)</span>
        <span class="n">maxLen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">decisIdx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">bwdAccumulate</span><span class="p">:</span>
            <span class="n">Fy</span> <span class="o">=</span> <span class="n">Fy</span><span class="p">[:,</span> <span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">maxLen</span><span class="p">:,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Fy</span> <span class="o">=</span> <span class="n">Fy</span><span class="p">[:,</span> <span class="p">:</span><span class="n">maxLen</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># compute the summed scores</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">minDecisLen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">decisIdx</span> <span class="o">=</span> <span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">nEp</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1"># (nTrl, nDecis) [nDecis x nTrl] number elements in the sum</span>
        <span class="n">sFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bwdAccumulate</span><span class="p">):</span> <span class="c1"># (nM, nTrl, nEp, nY) # [nY, nEp, nTrl, nM]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nEp</span> <span class="o">==</span> <span class="n">nEp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]):</span>
                    <span class="n">Fy</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="p">:</span><span class="n">nEp</span><span class="p">[</span><span class="n">ti</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Fy</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">nEp</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Fy</span> <span class="o">=</span> <span class="n">Fy</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">validFy</span> <span class="o">=</span> <span class="n">Fy</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">sFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">sFy</span> <span class="o">=</span> <span class="n">sFy</span><span class="p">[:,</span> <span class="n">decisIdx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># (nTrl, nDecis) number points in each sum</span>
        <span class="n">N</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">validFy</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (nTrl,nEp)</span>
        <span class="n">N</span>   <span class="o">=</span> <span class="n">N</span><span class="p">[:,</span> <span class="n">decisIdx</span><span class="p">]</span>

        <span class="c1">#N = np.tile(decisIdx[np.newaxis, :], (Fy.shape[-3], 1)) # (nTrl, nDecis) number points in each sum [ nDecis x nTrl ]</span>
        <span class="c1">#for ti, nti in enumerate(nEp): # and limit to trial length</span>
        <span class="c1">#    N[ti, :] = np.minimum(nti, N[ti, :])</span>

    <span class="c1"># compute the noise scale to transform to standardized units</span>
    <span class="n">sigma2</span><span class="p">,</span> <span class="n">Nsigma</span> <span class="o">=</span> <span class="n">estimate_Fy_noise_variance_2</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">decisIdx</span><span class="o">=</span><span class="n">decisIdx</span><span class="p">,</span> <span class="n">centFy</span><span class="o">=</span><span class="n">centFy</span><span class="p">,</span> <span class="n">detrendFy</span><span class="o">=</span><span class="n">detrendFy</span><span class="p">,</span> <span class="n">priorsigma</span><span class="o">=</span><span class="n">priorsigma</span><span class="p">)</span>

    <span class="c1"># scale = std-deviation over outputs of smoothed summed score at each decison point</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">normSum</span><span class="p">):</span>
        <span class="c1"># \sum_i N(0, sigma)) ~ N(0, sqrt(i)*sigma) </span>
        <span class="c1"># TODO: use N= number non-zero entries rather than just length..</span>
        <span class="n">sFy_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">.</span><span class="mi">01</span><span class="p">,</span><span class="n">N</span><span class="p">))</span> <span class="c1"># [ nDecis x nTrl ]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sFy_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma2</span><span class="p">)</span>
    <span class="c1">#plt.clf();plt.subplot(221);plt.plot(Fy[:, :, 0].T);plt.title(&#39;Fy&#39;);plt.subplot(222);plt.plot(fFy[:, :, 0].T);plt.title(&#39;fFy&#39;);plt.subplot(223);plt.plot(sFy[:, :, 0].T);plt.title(&#39;sFy&#39;);plt.subplot(224);plt.plot(sfFy[:, :, 0].T);plt.title(&#39;sfFy&#39;);plt.show()</span>
    <span class="c1">#sFy_scale_emp=np.std(sfFy[:, :, 0], 0)</span>
    <span class="c1">#print(np.mean((sFy_scale_emp[:, np.newaxis]/sFy_scale).ravel()))</span>
    <span class="c1">#plt.subplot(222);plt.plot(np.sqrt(sigma2), &#39;k&#39;);plt.plot(np.std(fFy[:, :, 0], 0), &#39;k.&#39;); plt.subplot(224);plt.plot(sFy_scale, &#39;k&#39;);plt.plot(np.std(sfFy[:, :, 0], 0), &#39;k.&#39;);plt.show()</span>
    <span class="c1">#plt.clf();plt.subplot(211);plt.plot(sFy[:, :, 0].T);plt.plot(sFy_scale[:, 0], &#39;k&#39;);plt.show()</span>
    <span class="c1">#print(&#39;sigma2 = {}&#39;.format(np.mean(sigma2.ravel())))</span>


    <span class="c1"># correction factor for sampling bias in the std</span>
    <span class="c1"># estimation of of the correction factors to</span>
    <span class="c1"># from: https://en.wikipedia.org/wiki/Unbiased_estimation_of_standard_deviation</span>
    <span class="c1"># E[sigma]=c4(n)*sigma -&gt; sigma = E[sigma]/c4(n)</span>
    <span class="c1"># where cf is the correction for the sampling bias in the estimator</span>
    <span class="k">if</span> <span class="n">nEpochCorrection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nEpochCorrection</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
        <span class="n">cf</span> <span class="o">=</span> <span class="n">c4</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nEpochCorrection</span><span class="p">))</span> 
        <span class="c1">#cf = c4(N/np.maximum(1, nEpochCorrection))**2 # too agressive </span>
        <span class="c1"># include the multiple comparsiosn correction factors</span>
        <span class="n">sFy_scale</span> <span class="o">=</span> <span class="n">sFy_scale</span> <span class="o">/</span> <span class="n">cf</span>

    <span class="c1"># apply the normalization to convert to z-score (i.e. unit-noise)</span>
    <span class="n">sFy_scale</span><span class="p">[</span><span class="n">sFy_scale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ssFy</span> <span class="o">=</span> <span class="n">sFy</span><span class="o">/</span><span class="n">sFy_scale</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># reverse the time reversal for backward accumulation    </span>
    <span class="k">if</span> <span class="n">bwdAccumulate</span><span class="p">:</span>
        <span class="n">ssFy</span> <span class="o">=</span> <span class="n">ssFy</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">sFy_scale</span> <span class="o">=</span> <span class="n">sFy_scale</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">N</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Fyshape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">3</span> <span class="p">:</span> <span class="c1"># convert back to have model dimension</span>
        <span class="n">ssFy</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ssFy</span><span class="p">,</span> <span class="p">(</span><span class="n">Fyshape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">ssFy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]))</span>
        <span class="n">sFy_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sFy_scale</span><span class="p">,</span> <span class="p">(</span><span class="n">Fyshape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">sFy_scale</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="n">nEp</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nEp</span><span class="p">,</span> <span class="n">Fyshape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">nY</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nY</span><span class="p">,</span> <span class="n">Fyshape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ssFy</span><span class="p">,</span> <span class="n">sFy_scale</span><span class="p">,</span> <span class="n">decisIdx</span><span class="p">,</span> <span class="n">nEp</span><span class="p">,</span> <span class="n">nY</span></div>

<div class="viewcode-block" id="get_valid_epochs_outputs"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.normalizeOutputScores.get_valid_epochs_outputs">[docs]</a><span class="k">def</span> <span class="nf">get_valid_epochs_outputs</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span><span class="n">validTgt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;get the number valid epoch and outputs from a zero-padded Fy set</span>

<span class="sd">    Args:</span>
<span class="sd">        Fy ([np.ndarray]): (nTrl,nEp,nY) the output scores</span>
<span class="sd">        validTgt ([np.ndarray]): (nTrl,nY) flag if this output is used in this trial </span>

<span class="sd">    Returns:</span>
<span class="sd">        nY ([np.ndarray]): (nTrl,) number valid outputs per trial</span>
<span class="sd">        nEp ([np.ndarray]): (nTrl,) number valid epochs per trial</span>
<span class="sd">        validTgt ([np.ndarray]): (nTrl,nY) flag if this output is used in this trial </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="n">validTgt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> <span class="c1"># (nM, nTr, nEp, nY)</span>
        <span class="n">validTgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Fy</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># (nM, nTr, nY) [ nY x nTrl ]</span>
    <span class="n">nY</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">validTgt</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># number active outputs in this trial (nM*nTrl) [ nTrl x nM ]</span>
    <span class="n">nEp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># number active epochs in each trial (nM*nTrl) [ nTrl x nM ]</span>
    <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Fy</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">nEp</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="c1"># num active epochs/samples</span>
    <span class="k">return</span> <span class="n">nY</span><span class="p">,</span> <span class="n">nEp</span><span class="p">,</span> <span class="n">validTgt</span></div>

<div class="viewcode-block" id="filter_Fy"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.normalizeOutputScores.filter_Fy">[docs]</a><span class="k">def</span> <span class="nf">filter_Fy</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">filtLen</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># apply the temporal smoothing filter to the raw scores</span>
    <span class="c1"># i.e. low-pass,  to remove short-term temporal </span>
    <span class="c1"># (anti)-correlations which add a lot of noise to the scale</span>
    <span class="c1"># estimation # (nM, nTrl, nEp, nY) # [nY, nEp, nTrl, nM]</span>
    <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">filtLen</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filtLen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">filtLen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Fy</span>
    
    <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filtLen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">filtLen</span><span class="p">,</span> <span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">filtLen</span><span class="p">))</span>  <span class="c1"># simple moving average filter</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filtLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

    <span class="c1">#B = np.array((.5,-1.5,2,-1.5,.5))/2 # simple high-pass filter</span>
    <span class="c1"># TODO []: how to norm B to achive properties we want?</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span> <span class="o">/</span>  <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
    <span class="c1"># TODO: good multi-dimensional filter... &amp; check correctness of the convolve</span>
    <span class="n">fFy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># (nTrl, nEp, nY) [ nY x nEp x nTrl ]</span>
    <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]):</span> <span class="c1"># trials loop</span>
        <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># outputs loop</span>
            <span class="n">fFy</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="p">:,</span> <span class="n">yi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Fy</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="p">:,</span> <span class="n">yi</span><span class="p">],</span> <span class="n">B</span><span class="p">)[:</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span> <span class="c1"># do the smoothing</span>
    <span class="c1"># compute the point weighting</span>
    <span class="n">wB</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">))[:</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span> <span class="c1"># point weighting for each element of fFy (nEp) [ nEp,  ]</span>
    <span class="c1"># normalize away the point weighting,  and startup effects</span>
    <span class="n">fFy</span> <span class="o">=</span> <span class="n">fFy</span><span class="o">/</span><span class="n">wB</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="c1">#w=np.ones(Fy.shape[1])</span>
    <span class="c1"># compare raw and filtered sum</span>
    <span class="c1">#sfFy  = np.cumsum(fFy, -2)[:, decisIdx, :] # (nTrl, nDecis, nY) [ nY x nDecis x nTrl] sfFy(y, T) = \sum_t=0^T fFy(y, t)</span>
    <span class="k">return</span> <span class="n">fFy</span></div>

<div class="viewcode-block" id="estimate_Fy_noise_variance_2"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.normalizeOutputScores.estimate_Fy_noise_variance_2">[docs]</a><span class="k">def</span> <span class="nf">estimate_Fy_noise_variance_2</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">decisIdx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centFy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detrendFy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">priorsigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">verb</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the noise variance for Fy</span>

<span class="sd">    Args:</span>
<span class="sd">        Fy ([np.ndarray]): (nTr,nEp,nY) the output scores</span>
<span class="sd">        decisIdx ([type], optional): [description]. Defaults to None.</span>
<span class="sd">        centFy (bool, optional): flag if we should center over outputs before computing variance. Defaults to True.</span>
<span class="sd">        detrendFy (bool, optional): flag if we should detrend Fy before computing it&#39;s variance. Defaults to True.</span>
<span class="sd">        priorsigma ([type], optional): Prior estimate for the variance. Defaults to None.</span>
<span class="sd">    returns:</span>
<span class="sd">        sigma2 ([np.ndarray]): (nTr, nDecis) estimated variance per sample at each decision point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">validFy</span> <span class="o">=</span> <span class="n">Fy</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">nY</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">validFy</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># number active outputs in this trial (nM*nTrl) </span>
    <span class="n">N</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">validFy</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (nTr, nEp) number valid epochs before time-point in trial</span>

    <span class="k">if</span> <span class="n">decisIdx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">decisIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># TODO [] : generalize by all possible accumul lengths at ass poss start points</span>
    <span class="c1"># TODO [] : make more computationally efficient? e.g. no explicit centering</span>
    <span class="n">cFy</span> <span class="o">=</span> <span class="n">Fy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># compute the cumulative sum</span>
    <span class="n">scFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">cFy</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># cum-sum from start # (nTr, nEp, nY)</span>

    <span class="c1"># remove per-example offset (if enough outputs to do reliably)</span>
    <span class="k">if</span> <span class="n">centFy</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nY</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">):</span>
        <span class="c1"># center at each time point, with guard for no active outputs (when mu should == 0)</span>
        <span class="n">muFy_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scFy</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">nY</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1"># mean at each time-point</span>
        <span class="n">scFy</span> <span class="o">=</span> <span class="n">scFy</span> <span class="o">-</span> <span class="n">muFy_y</span>

    <span class="c1"># variance of the summed scores over outputs for each time point</span>
    <span class="c1"># if independent then this should be a constant slope increase over time.</span>
    <span class="n">var2csFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scFy</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="n">nY</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (nTr,nEp) var over outputs for each cumsum</span>

    <span class="c1"># normalize out the constant slope over time, to get the equivalent slope if </span>
    <span class="c1"># we had N-indenpendent samples  </span>
    <span class="n">nvar2csFy</span> <span class="o">=</span> <span class="n">var2csFy</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="c1">#np.arange(1,var2csFy.shape[-1]+1) # ave var per-time-step</span>

    <span class="c1"># compute the average of the estimated slopes for each integeration length</span>
    <span class="n">muvar2csFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">nvar2csFy</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="c1"># np.arange(1,nvar2csFy.shape[-1]+1) # ave per-stime-stamp vars before each time-point</span>
    
    <span class="c1"># return the ave-cumsum-var-slope at each decision length</span>
    <span class="n">sigma2</span> <span class="o">=</span> <span class="n">muvar2csFy</span><span class="p">[:,</span><span class="n">decisIdx</span><span class="p">]</span> <span class="c1"># (nTr,nDecis)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">N</span><span class="p">[:,</span><span class="n">decisIdx</span><span class="p">]</span>

    <span class="c1"># include the prior if needed</span>
    <span class="k">if</span> <span class="n">priorsigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">priorsigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">:</span>
        <span class="c1"># include the effect of the prior, sigma is weighted combo pior and data</span>
        <span class="c1">#  sigma&#39;^2 = 1 / ( N_0/sigma_0^2 + N / sigma^2) </span>
        <span class="c1">#           = sigma_0^2 * sigma^2 / ( N_0 sigma^2 + N * sigma_0 )</span>
        <span class="n">osigma2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sigma2</span><span class="p">)</span>
        <span class="n">sigma2</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma2</span><span class="o">*</span><span class="n">decisIdx</span> <span class="o">+</span> <span class="n">priorsigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">priorsigma</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span> <span class="n">decisIdx</span> <span class="o">+</span> <span class="n">priorsigma</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
        <span class="c1">#print(&#39;sigma2 = {}  prior={} -&gt; {}&#39;.format(osigma2,priorsigma,np.mean(sigma2)))</span>
    
    <span class="k">return</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">N</span></div>


<div class="viewcode-block" id="estimate_Fy_noise_variance"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.normalizeOutputScores.estimate_Fy_noise_variance">[docs]</a><span class="k">def</span> <span class="nf">estimate_Fy_noise_variance</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">decisIdx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centFy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detrendFy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">priorsigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">verb</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the noise variance for Fy</span>

<span class="sd">    Args:</span>
<span class="sd">        Fy ([np.ndarray]): (nTr,nEp,nY) the output scores</span>
<span class="sd">        decisIdx ([type], optional): [description]. Defaults to None.</span>
<span class="sd">        centFy (bool, optional): flag if we should center over outputs before computing variance. Defaults to True.</span>
<span class="sd">        detrendFy (bool, optional): flag if we should detrend Fy before computing it&#39;s variance. Defaults to True.</span>
<span class="sd">        priorsigma ([type], optional): Prior estimate for the variance. Defaults to None.</span>
<span class="sd">    returns:</span>
<span class="sd">        sigma2 ([np.ndarray]): (nTr, nDecis) estimated variance per sample at each decision point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">decisIdx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">decisIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">sigma2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">decisIdx</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">Fy</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">N</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">decisIdx</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">Fyti</span> <span class="o">=</span> <span class="n">Fy</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># subset to valid entries, samples/outputs</span>
        <span class="n">vi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Fyti</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># active epochs/samples</span>
        <span class="n">Fyti</span> <span class="o">=</span> <span class="n">Fyti</span><span class="p">[</span><span class="n">vi</span><span class="p">,:]</span> <span class="c1"># remove the inactive </span>
        <span class="n">vY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Fyti</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># active outputs</span>
        <span class="n">Fyti</span> <span class="o">=</span> <span class="n">Fyti</span><span class="p">[:,</span><span class="n">vY</span><span class="p">]</span>

        <span class="c1"># get the decision points in the compressed representation</span>
        <span class="n">Nti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># #active epoch at each index == index-1</span>
        <span class="n">decisIdxti</span> <span class="o">=</span> <span class="n">Nti</span><span class="p">[</span><span class="n">decisIdx</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># index of the decision points in compressed Fy</span>
        <span class="n">N</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Nti</span><span class="p">[</span><span class="n">decisIdx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">Fyti</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sigma2</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># undefined if no active points!</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">detrendFy</span> <span class="ow">and</span> <span class="n">Fyti</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">:</span>
            <span class="c1"># center over time-points</span>
            <span class="n">muFy_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Fyti</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">Fyti</span> <span class="o">=</span> <span class="n">Fyti</span> <span class="o">-</span> <span class="n">muFy_t</span>

        <span class="c1"># compute the cumulative sum</span>
        <span class="n">sFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">Fyti</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># cum-sum from start # (nTr, nEp, nY)</span>

        <span class="c1"># remove per-example offset (if enough outputs to do reliably)</span>
        <span class="k">if</span> <span class="n">centFy</span> <span class="ow">and</span> <span class="n">Fyti</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
            <span class="c1"># center at each time point, with guard for no active outputs (when mu should == 0)</span>
            <span class="n">muFy_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sFy</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># mean at each time-point</span>
            <span class="n">sFy</span> <span class="o">=</span> <span class="n">sFy</span> <span class="o">-</span> <span class="n">muFy_y</span>

        <span class="c1"># variance of the summed scores over outputs for each time point</span>
        <span class="c1"># if independent then this should be a constant slope increase over time.</span>
        <span class="n">var2sFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sFy</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="n">sFy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (nTr,nEp) var over outputs for each cumsum</span>

        <span class="c1"># normalize out the constant slope over time, to get the equivalent slope if </span>
        <span class="c1"># we had N-indenpendent samples  </span>
        <span class="n">nvar2sFy</span> <span class="o">=</span> <span class="n">var2sFy</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">var2sFy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># ave var per-time-step</span>

        <span class="c1"># compute the average of the estimated slopes for each integeration length</span>
        <span class="n">muvar2sFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">nvar2sFy</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">var2sFy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># np.arange(1,nvar2csFy.shape[-1]+1) # ave per-stime-stamp vars before each time-point</span>
    
        <span class="c1"># return the ave-cumsum-var-slope at each decision length</span>
        <span class="n">sigma2</span><span class="p">[</span><span class="n">ti</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">muvar2sFy</span><span class="p">[</span><span class="n">decisIdxti</span><span class="p">]</span> <span class="c1"># (nTr,nDecis)</span>
        <span class="n">sigma2</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span><span class="n">decisIdxti</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># undefined if no active points!</span>
        

    <span class="c1"># include the prior if needed</span>
    <span class="k">if</span> <span class="n">priorsigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">priorsigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">:</span>
        <span class="c1"># include the effect of the prior, sigma is weighted combo pior and data</span>
        <span class="c1">#  sigma&#39;^2 = 1 / ( N_0/sigma_0^2 + N / sigma^2) </span>
        <span class="c1">#           = sigma_0^2 * sigma^2 / ( N_0 sigma^2 + N * sigma_0 )</span>
        <span class="n">osigma2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sigma2</span><span class="p">)</span>
        <span class="n">sigma2</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma2</span><span class="o">*</span><span class="n">N</span> <span class="o">+</span> <span class="n">priorsigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">priorsigma</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span> <span class="n">N</span> <span class="o">+</span> <span class="n">priorsigma</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
        <span class="c1">#print(&#39;sigma2 = {}  prior={} -&gt; {}&#39;.format(osigma2,priorsigma,np.mean(sigma2)))</span>
    
    <span class="k">return</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">N</span></div>


<span class="c1">#@function</span>
<div class="viewcode-block" id="c4"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.normalizeOutputScores.c4">[docs]</a><span class="k">def</span> <span class="nf">c4</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># correction factor for bias in the standard deviation  </span>
<span class="c1"># from: https://en.wikipedia.org/wiki/Unbiased_estimation_of_standard_deviation</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">cf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">32</span><span class="o">*</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">19</span> <span class="o">/</span> <span class="mi">128</span><span class="o">*</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cf</span></div>

<div class="viewcode-block" id="plot_normalizedScores"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.normalizeOutputScores.plot_normalizedScores">[docs]</a><span class="k">def</span> <span class="nf">plot_normalizedScores</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">ssFy</span><span class="p">,</span> <span class="n">scale_sFy</span><span class="p">,</span> <span class="n">decisIdx</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;plot the normalized score and raw summed score for comparsion &#39;&#39;&#39;</span>
    <span class="n">sFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># (nEp, nY)</span>
    <span class="n">stdsFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sFy</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#stdsFy = np.sum((sFy-np.mean(sFy,-1,keepdims=True))**2, -1) /sFy.shape[-1] / np.arange(1,sFy.shape[-2]+1)</span>
    <span class="c1">#stdsFy = np.cumsum(stdsFy) / np.arange(1,stdsFy.shape[-1]+1)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sFy=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sFy</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">decisIdx</span><span class="p">,</span> <span class="n">sFy</span><span class="p">[</span><span class="n">decisIdx</span><span class="p">,</span> <span class="p">:])</span> 
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">decisIdx</span><span class="p">,</span> <span class="n">scale_sFy</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;scale_sFy&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">stdsFy</span><span class="p">,</span> <span class="s1">&#39;k.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;std cumsum(Fy)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Non-normalized sum - scale&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">decisIdx</span><span class="p">,</span> <span class="n">ssFy</span><span class="p">)</span>
    <span class="n">stdssFy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ssFy</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">decisIdx</span><span class="p">,</span> <span class="n">stdssFy</span><span class="p">[</span><span class="n">decisIdx</span><span class="p">,:],</span><span class="s1">&#39;k.&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;std ssFy&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;scaled sum&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;ssFy&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;epoch&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<span class="c1">#@function</span>
<div class="viewcode-block" id="mktestFy"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.normalizeOutputScores.mktestFy">[docs]</a><span class="k">def</span> <span class="nf">mktestFy</span><span class="p">(</span><span class="n">nY</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nM</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nEp</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span> <span class="n">nTrl</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">sigstr</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">startupNoisefrac</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">offsetstr</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">trlenfrac</span><span class="o">=.</span><span class="mi">25</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">nM</span><span class="p">,</span> <span class="n">nTrl</span><span class="p">,</span> <span class="n">nEp</span><span class="p">,</span> <span class="n">nY</span><span class="p">))</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="c1"># add an offset to the scores...</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">offsetstr</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">noise</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span> <span class="c1"># (nEp)</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span><span class="o">+</span><span class="n">offset</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1"># (nM, nTrl, nEp, nY) [ nYxnEpxnTrlxnM ]</span>


    <span class="n">sigamp</span> <span class="o">=</span> <span class="n">sigstr</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">noise</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span> <span class="c1"># (nEp)</span>
    <span class="c1"># no signal at the start of the trial</span>
    <span class="n">startupNoise_samp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nEp</span><span class="o">*</span><span class="n">startupNoisefrac</span><span class="p">)</span>
    <span class="n">sigamp</span><span class="p">[:</span><span class="n">startupNoise_samp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">noise</span><span class="p">[:,:,:</span><span class="n">startupNoise_samp</span><span class="p">,:]</span><span class="o">=</span><span class="mi">0</span>

    <span class="c1"># measure is sig + noise</span>
    <span class="n">Fy</span> <span class="o">=</span> <span class="n">noise</span>
    <span class="n">Fy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sigamp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># (nM, nTrl, nEp, nY) [nEp x nTrl]</span>
    
    <span class="c1"># make variable length trials,  and per-trial offset</span>
    <span class="n">nEp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]):</span>
        <span class="c1"># trial offset</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">()</span>
        <span class="n">Fy</span><span class="p">[:,</span>  <span class="n">ti</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Fy</span><span class="p">[:,</span> <span class="n">ti</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">mu</span>
        <span class="c1"># trial end time</span>
        <span class="n">nEp</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">()</span><span class="o">*</span><span class="n">trlenfrac</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">trlenfrac</span><span class="p">))</span>
        <span class="n">Fy</span><span class="p">[:,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">nEp</span><span class="p">[</span><span class="n">ti</span><span class="p">]:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">nEp</span></div>

<div class="viewcode-block" id="testcase"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.normalizeOutputScores.testcase">[docs]</a><span class="k">def</span> <span class="nf">testcase</span><span class="p">():</span>
    <span class="n">detrendFy</span><span class="o">=</span><span class="kc">True</span>
    <span class="n">centFy</span><span class="o">=</span><span class="kc">True</span>

    <span class="kn">from</span> <span class="nn">normalizeOutputScores</span> <span class="kn">import</span> <span class="n">mktestFy</span><span class="p">,</span>  <span class="n">normalizeOutputScores</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="n">Fy</span><span class="p">,</span> <span class="n">nEp</span> <span class="o">=</span> <span class="n">mktestFy</span><span class="p">(</span><span class="n">sigstr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#(nM, nTrl, nEp, nY)</span>
    <span class="n">Fy</span> <span class="o">=</span> <span class="n">Fy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="c1"># (nTrl,nEp,nY)</span>
    <span class="c1"># Introduce temporal and spatial sparsity like real data</span>
    <span class="n">Fy</span> <span class="o">=</span> <span class="n">Fy</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">Fy</span><span class="p">[:,:</span><span class="mi">20</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># block zero at start</span>

    <span class="n">Fy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># only 50% active</span>
    <span class="n">Fy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># only 50% active</span>
    <span class="n">oFy</span><span class="o">=</span><span class="n">Fy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fy=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    
    <span class="c1"># visualize all trials true-target normalized scores</span>
    <span class="n">ssFy</span><span class="p">,</span> <span class="n">scale_sFy</span><span class="p">,</span> <span class="n">decisIdx</span><span class="p">,</span> <span class="n">nEp</span><span class="p">,</span> <span class="n">nY</span> <span class="o">=</span> <span class="n">normalizeOutputScores</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">minDecisLen</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nEpochCorrection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">centFy</span><span class="o">=</span><span class="n">centFy</span><span class="p">,</span> <span class="n">detrendFy</span><span class="o">=</span><span class="n">detrendFy</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ssFy=</span><span class="si">{}</span><span class="s1"> scale_sFy=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ssFy</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">scale_sFy</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="c1">#%matplotlib</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plot_normalizedScores</span><span class="p">(</span><span class="n">oFy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">],</span><span class="n">ssFy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:],</span><span class="n">scale_sFy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">decisIdx</span><span class="p">)</span>

    <span class="c1"># introduce temporal correlations and visualize</span>
    <span class="n">Fy</span> <span class="o">=</span> <span class="n">filter_Fy</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">filtLen</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">ssFy</span><span class="p">,</span> <span class="n">scale_sFy</span><span class="p">,</span> <span class="n">decisIdx</span><span class="p">,</span> <span class="n">nEp</span><span class="p">,</span> <span class="n">nY</span> <span class="o">=</span> <span class="n">normalizeOutputScores</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">minDecisLen</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nEpochCorrection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">centFy</span><span class="o">=</span><span class="n">centFy</span><span class="p">,</span> <span class="n">detrendFy</span><span class="o">=</span><span class="n">detrendFy</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pre-filtered ssFy=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ssFy</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="c1">#%matplotlib</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;filtered </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">plot_normalizedScores</span><span class="p">(</span><span class="n">Fy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:],</span><span class="n">ssFy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:],</span><span class="n">scale_sFy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">decisIdx</span><span class="p">)</span>

    <span class="c1"># introduce temporal correlations and visualize</span>
    <span class="n">Fy</span> <span class="o">=</span> <span class="n">filter_Fy</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">ssFy</span><span class="p">,</span> <span class="n">scale_sFy</span><span class="p">,</span> <span class="n">decisIdx</span><span class="p">,</span> <span class="n">nEp</span><span class="p">,</span> <span class="n">nY</span> <span class="o">=</span> <span class="n">normalizeOutputScores</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">minDecisLen</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nEpochCorrection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">centFy</span><span class="o">=</span><span class="n">centFy</span><span class="p">,</span> <span class="n">detrendFy</span><span class="o">=</span><span class="n">detrendFy</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pre-filtered ssFy=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ssFy</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="c1">#%matplotlib</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;anti-correlated&#39;</span><span class="p">)</span>
    <span class="n">plot_normalizedScores</span><span class="p">(</span><span class="n">Fy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:],</span><span class="n">ssFy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:],</span><span class="n">scale_sFy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">decisIdx</span><span class="p">)</span></div>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">testcase</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Mark van Kesteren

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>