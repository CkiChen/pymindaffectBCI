

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mindaffectBCI.decoder.utils &mdash; mindaffectBCI - documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> mindaffectBCI
          

          
            
            <img src="../../../_static/MindAffect_Logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../OnlineBCI_quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">mindaffectBCI</a></li>
</ul>
<p class="caption"><span class="caption-text">The headset</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../printing_guide.html">Print Your Own Headset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fitting_guide.html">Setup &amp; fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../headset_layout.html">Headset layout</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mindaffectBCI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mindaffectBCI.decoder.utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mindaffectBCI.decoder.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># time-series tests</span>
<div class="viewcode-block" id="window_axis"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.window_axis">[docs]</a><span class="k">def</span> <span class="nf">window_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">winsz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prependwindowdim</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; efficient view-based slicing of equal-sized equally-spaced windows along a selected axis of a numpy nd-array &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># no negative axis indices</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="n">axis</span>

    <span class="c1"># compute the shape/strides for the  windowed view of a</span>
    <span class="k">if</span> <span class="n">prependwindowdim</span><span class="p">:</span> <span class="c1"># window dim before axis</span>
        <span class="n">shape</span>  <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">winsz</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">-</span><span class="n">winsz</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span>  <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[(</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span>
        <span class="n">strides</span> <span class="o">=</span>  <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">*</span><span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[(</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># window dim after axis</span>
        <span class="n">shape</span>  <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">-</span><span class="n">winsz</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">winsz</span><span class="p">)</span> <span class="o">+</span>  <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[(</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span>
        <span class="n">strides</span> <span class="o">=</span>  <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[(</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span>
    <span class="c1">#print(&quot;a={}&quot;.format(a.shape))</span>
    <span class="c1">#print(&quot;shape={} stride={}&quot;.format(shape,strides))</span>
        
    <span class="c1"># return the computed view</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span></div>

<div class="viewcode-block" id="equals_subarray"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.equals_subarray">[docs]</a><span class="k">def</span> <span class="nf">equals_subarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">match</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; efficiently find matches of a 1-d sub-array along axis within an nd-array &#39;&#39;&#39;</span> 
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># no negative dims</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="o">+</span><span class="n">axis</span>
    <span class="c1"># reshape to match dims of a</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="n">pat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span> <span class="c1"># ensure is numpy</span>
    <span class="n">pshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">);</span> <span class="n">pshape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">size</span>
    <span class="n">pat</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pat</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pshape</span><span class="p">)</span> <span class="c1"># [ ... x l x...]</span>
    <span class="c1"># window a into pat-len pieces</span>
    <span class="n">aw</span> <span class="o">=</span> <span class="n">window_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pat</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="c1"># [ ... x t-l x l x ...]</span>
    <span class="c1"># do the match</span>
    <span class="n">F</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">aw</span><span class="p">,</span> <span class="n">pat</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [... x t-l x ...]</span>
    <span class="c1"># pad to make the same shape as input</span>
    <span class="n">padshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">);</span> <span class="n">padshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">-</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">match</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># match at end of pattern -&gt; pad before</span>
        <span class="n">F</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padshape</span><span class="p">),</span> <span class="n">F</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># match at start of pattern -&gt; pad after</span>
        <span class="n">F</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">padshape</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F</span></div>


<div class="viewcode-block" id="RingBuffer"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.RingBuffer">[docs]</a><span class="k">class</span> <span class="nc">RingBuffer</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39; time efficient linear ring-buffer for storing packed data, e.g. continguous np-arrays &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elementshape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bufshape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">maxsize</span><span class="p">),</span> <span class="p">)</span><span class="o">+</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">maxsize</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># store as 2d</span>
        <span class="c1"># position for the -1 element. N.B. start maxsize so pos-maxsize is always valid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxsize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># count of total number elements added to the buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copypos</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># position of the last element copied to the 1st half</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copysize</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># number entries to copy as a block</span>

<div class="viewcode-block" id="RingBuffer.clear"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.RingBuffer.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bufshape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span>  <span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copypos</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copysize</span><span class="o">=</span><span class="mi">0</span></div>

<div class="viewcode-block" id="RingBuffer.append"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.RingBuffer.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;add single element to the ring buffer&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="RingBuffer.extend"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.RingBuffer.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;add a group of elements to the ring buffer&#39;&#39;&#39;</span>
        <span class="c1"># TODO[] : incremental copy to the 1st half, to spread the copy cost?</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">+</span><span class="n">nx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">flippos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span>
            <span class="c1"># flippos-nx to 1st half</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[:(</span><span class="n">flippos</span><span class="o">-</span><span class="n">nx</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">-</span><span class="p">(</span><span class="n">flippos</span><span class="o">-</span><span class="n">nx</span><span class="p">)):</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># move cursor to end 1st half</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">flippos</span><span class="o">-</span><span class="n">nx</span>

        <span class="c1"># insert in the buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">+</span><span class="n">nx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span>  <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># move the cursor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">+</span><span class="n">nx</span>
        <span class="c1"># update the count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">nx</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bufshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">bufshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    
<div class="viewcode-block" id="RingBuffer.unwrap"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.RingBuffer.unwrap">[docs]</a>    <span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;get a view on the valid portion of the ring buffer&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bufshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unwrap</span><span class="p">()[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unwrap</span><span class="p">())</span></div>

<div class="viewcode-block" id="extract_ringbuffer_segment"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.extract_ringbuffer_segment">[docs]</a><span class="k">def</span> <span class="nf">extract_ringbuffer_segment</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="n">bgn_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; extract the data between start/end time stamps&#39;&#39;&#39;</span>
    <span class="c1"># get the data / msgs from the ringbuffers</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">unwrap</span><span class="p">()</span> <span class="c1"># (nsamp,nch+1)</span>
    <span class="n">X_ts</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># last channel is timestamps</span>
    <span class="c1"># TODO: binary-search to make these searches more efficient!</span>
    <span class="c1"># search backwards for trial-start time-stamp</span>
    <span class="c1"># TODO[] : use a bracketing test.. (better with wrap-arround)</span>
    <span class="n">bgn_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bgn_ts</span> <span class="o">&lt;=</span> <span class="n">X_ts</span><span class="p">,</span> <span class="n">X_ts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># get the index of this timestamp, guarding for after last sample</span>
    <span class="n">bgn_samp</span> <span class="o">=</span> <span class="n">bgn_samp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bgn_samp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_ts</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="c1"># and just to be sure the trial-end timestamp</span>
    <span class="k">if</span>  <span class="n">end_ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">end_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">X_ts</span> <span class="o">&lt;</span> <span class="n">end_ts</span><span class="p">,</span> <span class="n">X_ts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># get index of this timestamp, guarding for after last data sample</span>
        <span class="n">end_samp</span> <span class="o">=</span> <span class="n">end_samp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_samp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_ts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># until now</span>
        <span class="n">end_samp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_ts</span><span class="p">)</span>
    <span class="c1"># extract the trial data, and make copy (just to be sure)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">bgn_samp</span><span class="p">:</span><span class="n">end_samp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">X</span></div>

<span class="c1"># toy data generation</span>

<span class="c1">#@function</span>
<div class="viewcode-block" id="randomSummaryStats"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.randomSummaryStats">[docs]</a><span class="k">def</span> <span class="nf">randomSummaryStats</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nE</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nY</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="c1"># pure random test-case</span>
    <span class="n">Cxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">Cxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">nY</span><span class="p">,</span> <span class="n">nE</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">Cyy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">nY</span><span class="p">,</span> <span class="n">nE</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">nE</span><span class="p">,</span> <span class="n">tau</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Cxx</span><span class="p">,</span> <span class="n">Cxy</span><span class="p">,</span> <span class="n">Cyy</span><span class="p">)</span></div>

<div class="viewcode-block" id="testNoSignal"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.testNoSignal">[docs]</a><span class="k">def</span> <span class="nf">testNoSignal</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nE</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nY</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">isi</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nSamp</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">nTrl</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Simple test-problem -- no real signal</span>
    <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">isi</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">nTrl</span><span class="p">,</span> <span class="n">nSamp</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">stimTimes_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">tau</span><span class="p">,</span> <span class="n">isi</span><span class="p">)</span>
    <span class="n">Me</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">nTrl</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stimTimes_samp</span><span class="p">),</span> <span class="n">nY</span><span class="p">,</span> <span class="n">nE</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">1</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nTrl</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">nY</span><span class="p">,</span> <span class="n">nE</span><span class="p">))</span>
    <span class="n">Y</span><span class="p">[:,</span> <span class="n">stimTimes_samp</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Me</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">stimTimes_samp</span><span class="p">)</span></div>

<div class="viewcode-block" id="testSignal"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.testSignal">[docs]</a><span class="k">def</span> <span class="nf">testSignal</span><span class="p">(</span><span class="n">nTrl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nE</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nY</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">isi</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nSamp</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">stimthresh</span><span class="o">=.</span><span class="mi">6</span><span class="p">,</span> <span class="n">noise2signal</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">irf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1">#simple test problem, with overlapping response</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">if</span> <span class="n">irf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">irf</span><span class="p">)</span>
    <span class="n">nEp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">nSamp</span><span class="o">-</span><span class="n">tau</span><span class="p">)</span><span class="o">/</span><span class="n">isi</span><span class="p">)</span>
    <span class="n">cb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">nEp</span><span class="p">,</span> <span class="n">nY</span><span class="p">,</span> <span class="n">nE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">stimthresh</span> <span class="c1"># codebook = per-epoch stimulus activity</span>
    <span class="n">E</span>  <span class="o">=</span> <span class="n">cb</span> <span class="c1"># (nEp, nY, nE) # per-epoch stimulus activity</span>
    <span class="c1"># up-sample to sample rate</span>
    <span class="n">stimTimes_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nSamp</span><span class="o">-</span><span class="n">tau</span><span class="p">,</span> <span class="n">isi</span><span class="p">)</span> <span class="c1"># (nEp)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nSamp</span><span class="p">,</span> <span class="n">nY</span><span class="p">,</span> <span class="n">E</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Y</span><span class="p">[</span><span class="n">stimTimes_samp</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">E</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">stimTimes_samp</span><span class="p">),</span> <span class="p">:,</span> <span class="p">:]</span> <span class="c1">#per-sample stimulus activity (nSamp, nY, nE) [nE x nY x nSamp]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">Y</span><span class="p">,(</span><span class="n">nTrl</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># replicate for the trials</span>
    <span class="c1"># generate the brain source</span>
    <span class="n">A</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">nE</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="c1"># spatial-pattern for the source signal</span>
    <span class="k">if</span> <span class="n">irf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">B</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tau</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>         <span class="c1"># true response filter (shift by 10 samples)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">irf</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">Ytrue</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># (nTrl, nSamp, nE)</span>

    <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># convolve with the impulse response - manually using window_axis</span>
        <span class="c1"># zero pad before for the sliding window</span>
        <span class="n">Ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ytrue</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">Ytrue</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">tau</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span><span class="o">+</span><span class="n">Ytrue</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">Ys</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">tau</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">offset</span><span class="p">:</span><span class="n">Ytrue</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">tau</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Ytrue</span> <span class="c1"># zero-pad at front + include the offset.</span>
        <span class="n">Yse</span> <span class="o">=</span> <span class="n">window_axis</span><span class="p">(</span><span class="n">Ys</span><span class="p">,</span> <span class="n">winsz</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># (nTr,nSamp,tau,nE)</span>
        <span class="n">YtruecB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;Tste,t-&gt;Tse&quot;</span><span class="p">,</span> <span class="n">Yse</span><span class="p">,</span> <span class="n">B</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># N.B. time-reverse irf (nTr,nSamp,nE)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># use the np convolve function, N.B. implicitly time reverses B (like we want)</span>
        <span class="n">YtruecB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Ytrue</span><span class="p">[:,</span> <span class="n">ei</span><span class="p">],</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ytrue</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span><span class="o">.</span><span class="n">T</span> <span class="c1">#(nSamp+pad, nE) [nE x nSamp]</span>
        <span class="n">YtruecB</span> <span class="o">=</span> <span class="n">YtruecB</span><span class="p">[:</span><span class="n">Ytrue</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="c1"># trim the padding</span>

    <span class="c1">#import matplotlib.pyplot as plt; plt.clf(); plt.plot(Ytrue[:100,0],&#39;b*&#39;,label=&#39;Y&#39;); plt.plot(YtruecB[:100,0],&#39;g*&#39;,label=&#39;Y*B&#39;); plt.plot(B,&#39;k&#39;,label=&#39;B&#39;); plt.legend()</span>

    <span class="c1">#print(&quot;Ytrue={}&quot;.format(Ytrue.shape))</span>
    <span class="c1">#print(&quot;YtruecB={}&quot;.format(YtruecB.shape))</span>
    <span class="n">S</span>  <span class="o">=</span> <span class="n">YtruecB</span> <span class="c1"># (nTr, nSamp, nE) true response, i.e. filtered Y </span>
    <span class="n">N</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">d</span><span class="p">,))</span> <span class="c1"># EEG noise (nTr, nSamp, d)</span>
    <span class="n">X</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;tse,ed-&gt;tsd&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise2signal</span><span class="o">*</span><span class="n">N</span>       <span class="c1"># simulated data.. true source mapped through spatial pattern (nSamp, d) #[d x nSamp]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">stimTimes_samp</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span></div>

<div class="viewcode-block" id="testtestSignal"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.testtestSignal">[docs]</a><span class="k">def</span> <span class="nf">testtestSignal</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="c1"># shift by 5</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">irf</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">st</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">testSignal</span><span class="p">(</span><span class="n">nTrl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nSamp</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nE</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nY</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">isi</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">irf</span><span class="o">=</span><span class="n">irf</span><span class="p">,</span><span class="n">noise2signal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">311</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;offset=</span><span class="si">{}</span><span class="s2">, irf=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">irf</span><span class="p">));</span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="c1"># back-shift-by-5 -&gt; 0 shift</span>
    <span class="n">offset</span><span class="o">=-</span><span class="mi">5</span>
    <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">st</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">testSignal</span><span class="p">(</span><span class="n">nTrl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nSamp</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nE</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nY</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">isi</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">irf</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">noise2signal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">312</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;offset=</span><span class="si">{}</span><span class="s2">, irf=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">irf</span><span class="p">));</span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="c1"># back-shift-by-10 -&gt; -5 shift</span>
    <span class="n">offset</span><span class="o">=-</span><span class="mi">9</span>
    <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">st</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">testSignal</span><span class="p">(</span><span class="n">nTrl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nSamp</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nE</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nY</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">isi</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span><span class="n">irf</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">noise2signal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">313</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;offset=</span><span class="si">{}</span><span class="s2">, irf=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">irf</span><span class="p">));</span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span></div>
    

<div class="viewcode-block" id="sliceData"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.sliceData">[docs]</a><span class="k">def</span> <span class="nf">sliceData</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">stimTimes_samp</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># make a sliced version</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">stimTimes_samp</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dst</span> <span class="o">==</span> <span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">stimTimes_samp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># fast path equaly spaced stimTimes</span>
        <span class="n">Xe</span> <span class="o">=</span> <span class="n">window_axis</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">winsz</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">prependwindowdim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># (nTrl, nEp, tau, d) #d x tau x ep x trl</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">Xe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stimTimes_samp</span><span class="p">),</span> <span class="n">tau</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># (nTrl, nEp, tau, d) [ d x tau x nEp x nTrl ]</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stimTimes_samp</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">si</span><span class="o">+</span><span class="n">tau</span><span class="p">)</span>
            <span class="n">Xe</span><span class="p">[:,</span> <span class="n">ei</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">Xe</span></div>

<div class="viewcode-block" id="sliceY"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.sliceY">[docs]</a><span class="k">def</span> <span class="nf">sliceY</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">stimTimes_samp</span><span class="p">,</span> <span class="n">featdim</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Y = (nTrl, nSamp, nY, nE) if featdim=True</span>
<span class="sd">    OR</span>
<span class="sd">    Y=(nTrl, nSamp, nY) if featdim=False #(nE x nY x nSamp x nTrl)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># make a sliced version</span>
    <span class="n">si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stimTimes_samp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">featdim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Y</span><span class="p">[:,</span> <span class="n">si</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">Y</span><span class="p">[</span><span class="n">si</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Y</span><span class="p">[:,</span> <span class="n">si</span><span class="p">,</span> <span class="p">:]</span> <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">Y</span><span class="p">[</span><span class="n">si</span><span class="p">,</span> <span class="p">:]</span></div>

    
<div class="viewcode-block" id="block_randomize"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.block_randomize">[docs]</a><span class="k">def</span> <span class="nf">block_randomize</span><span class="p">(</span><span class="n">true_target</span><span class="p">,</span> <span class="n">npermute</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; make a block random permutaton of the input array</span>
<span class="sd">    Inputs:</span>
<span class="sd">       npermute: int - number permutations to make</span>
<span class="sd">       true_target: (..., nEp, nY, e): true target value for nTrl trials of length nEp flashes</span>
<span class="sd">       axis : int the axis along which to permute true_target&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">true_target</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;true target info must be at least 3d&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">true_target</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only implementated for axis=-2 currently&quot;</span><span class="p">)</span>
    
    <span class="c1"># estimate the number of blocks to use</span>
    <span class="k">if</span> <span class="n">block_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">true_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">npermute</span><span class="p">)</span>

    <span class="n">nblk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">true_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">/</span><span class="n">block_size</span><span class="p">))</span>
    <span class="n">blk_lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">true_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">nblk</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># convert to start/end index for each block</span>
    <span class="n">blk_lims</span> <span class="o">=</span> <span class="p">[(</span><span class="n">blk_lims</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">blk_lims</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blk_lims</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">cb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">true_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">npermute</span><span class="p">,</span> <span class="n">true_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">di</span><span class="p">,</span> <span class="n">dest_blk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">blk_lims</span><span class="p">):</span>
            
            <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">true_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blk_lims</span><span class="p">))</span>
            <span class="c1"># ensure can&#39;t be the same block</span>
            <span class="k">if</span> <span class="n">si</span> <span class="o">==</span> <span class="n">di</span><span class="p">:</span>
                <span class="n">si</span> <span class="o">=</span> <span class="n">si</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">si</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">blk_lims</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">si</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">src_blk</span> <span class="o">=</span> <span class="n">blk_lims</span><span class="p">[</span><span class="n">si</span><span class="p">]</span>
            <span class="c1"># guard for different lengths for source/dest blocks</span>
            <span class="n">dest_len</span> <span class="o">=</span> <span class="n">dest_blk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dest_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dest_len</span> <span class="o">&gt;</span> <span class="n">src_blk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">src_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">src_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dest_len</span> <span class="o">&lt;</span> <span class="n">true_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
                    <span class="c1"># enlarge the src</span>
                    <span class="n">src_blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">src_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">src_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dest_len</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">src_blk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dest_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">src_blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">src_blk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dest_len</span><span class="p">,</span> <span class="n">src_blk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t fit source and dest&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dest_len</span> <span class="o">&lt;</span> <span class="n">src_blk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">src_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">src_blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">src_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">src_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dest_len</span><span class="p">)</span>
            
            <span class="n">cb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">dest_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">dest_blk</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ti</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">true_target</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">src_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">src_blk</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">yi</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">cb</span></div>


<div class="viewcode-block" id="upsample_codebook"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.upsample_codebook">[docs]</a><span class="k">def</span> <span class="nf">upsample_codebook</span><span class="p">(</span><span class="n">trlen</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">ep_idx</span><span class="p">,</span> <span class="n">stim_dur_samp</span><span class="p">,</span> <span class="n">offset_samp</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
    <span class="sd">&#39;&#39;&#39; upsample a codebook definition to sample rate</span>
<span class="sd">    Inputs:</span>
<span class="sd">       trlen : (int) length after up-sampling</span>
<span class="sd">       cb : (nTr, nEp, ...) the codebook</span>
<span class="sd">       ep_idx : (nTr, nEp) the indices of the codebook  entries</span>
<span class="sd">       stim_dur_samp: (int) the amount of time the cb entry is held for</span>
<span class="sd">       offset_samp : (2,):int the offset for the stimulus in the upsampled trlen data</span>
<span class="sd">    Outputs:</span>
<span class="sd">       Y : ( nTrl, trlen, ...) the up-sampled codebook &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">ep_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">cb</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">ep_idx</span><span class="o">.</span><span class="n">ndim</span><span class="p">]</span> <span class="o">==</span> <span class="n">ep_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;codebook and epoch indices must has same shape&quot;</span><span class="p">)</span>
        <span class="n">trl_idx</span> <span class="o">=</span> <span class="n">ep_idx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># start each trial</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># make dummy ep_idx with 0 for every trial!</span>
        <span class="n">ep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">trl_idx</span> <span class="o">=</span> <span class="n">ep_idx</span>
        
    <span class="n">Y</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trlen</span><span class="p">)</span><span class="o">+</span> <span class="n">cb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span> <span class="c1"># (nTr, nSamp, ...)</span>
    <span class="k">for</span> <span class="n">ti</span><span class="p">,</span> <span class="n">trl_start_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trl_idx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">epidx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ep_idx</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="p">:]):</span>
            <span class="k">if</span> <span class="n">ei</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">epidx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># zero indicates end of variable length trials</span>
                <span class="k">break</span>
            <span class="c1"># start index for this epoch in this *trial*, including the 0-offset </span>
            <span class="n">ep_start_idx</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">offset_samp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">epidx</span><span class="o">-</span><span class="n">trl_start_idx</span><span class="p">)</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">ep_start_idx</span><span class="p">:(</span><span class="n">ep_start_idx</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">stim_dur_samp</span><span class="p">)),</span> <span class="o">...</span><span class="p">]</span>  <span class="o">=</span> <span class="n">cb</span><span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Y</span></div>


<div class="viewcode-block" id="lab2ind"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.lab2ind">[docs]</a><span class="k">def</span> <span class="nf">lab2ind</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span><span class="n">lab2class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; convert a list of labels (as integers) to a class indicator matrix&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">lab2class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lab2class</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">l</span><span class="p">,)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span> <span class="p">]</span> <span class="c1"># N.B. list of lists</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">lab</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lab</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lab2class</span><span class="p">),),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">li</span><span class="p">,</span><span class="n">ls</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lab2class</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">lab</span> <span class="o">==</span> <span class="n">l</span><span class="p">,</span> <span class="n">li</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">lab2class</span><span class="p">)</span></div>



<div class="viewcode-block" id="zero_outliers"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.zero_outliers">[docs]</a><span class="k">def</span> <span class="nf">zero_outliers</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">badEpThresh</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">badEpChThresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;identify and zero-out bad/outlying data</span>

<span class="sd">    Inputs:</span>
<span class="sd">      X = (nTrl, nSamp, d)</span>
<span class="sd">      Y = (nTrl, nSamp, nY, nE) OR (nTrl, nSamp, nE)</span>
<span class="sd">               nE=#event-types  nY=#possible-outputs  nEpoch=#stimulus events to process</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># remove whole bad epochs first</span>
    <span class="k">if</span> <span class="n">badEpThresh</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bad_ep</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">idOutliers</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">badEpThresh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># ave over time,ch</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bad_ep</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> badEp&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bad_ep</span><span class="o">.</span><span class="n">ravel</span><span class="p">())))</span>
            <span class="c1"># copy X,Y so don&#39;t modify in place!</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">X</span><span class="p">[</span><span class="n">bad_ep</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1">#print(&quot;Y={}, Ybad={}&quot;.format(Y.shape, Y[bad_ep[..., 0, 0], ...].shape))</span>
            <span class="c1"># zero out Y also, so don&#39;t try to &#39;fit&#39; the bad zeroed data</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">bad_ep</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
            
    <span class="c1"># Remove bad individual channels next</span>
    <span class="k">if</span> <span class="n">badEpChThresh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">badEpChThresh</span> <span class="o">=</span> <span class="n">badEpThresh</span><span class="o">*</span><span class="mi">2</span> 
    <span class="k">if</span> <span class="n">badEpChThresh</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bad_epch</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">idOutliers</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">badEpChThresh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># ave over time</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bad_epch</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> badEpCh&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bad_epch</span><span class="o">.</span><span class="n">ravel</span><span class="p">())))</span>
            <span class="c1"># make index expression to zero out the bad entries</span>
            <span class="n">badidx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">bad_epch</span><span class="p">))</span> <span class="c1"># convert to linear indices</span>
            <span class="n">badidx</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># broadcast over the accumulated dimensions</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bad_ep</span><span class="p">):</span> <span class="c1"># copy so don&#39;t update in place</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">X</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">badidx</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span></div>


<div class="viewcode-block" id="idOutliers"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.idOutliers">[docs]</a><span class="k">def</span> <span class="nf">idOutliers</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; identify outliers with excessively high power in the input data</span>
<span class="sd">    Inputs:</span>
<span class="sd">      X:float the data to identify outliers in</span>
<span class="sd">      axis:int (-2)  axis of X to sum to get power</span>
<span class="sd">      thresh(float): threshold standard deviation for outlier detection</span>
<span class="sd">      verbosity(int): verbosity level</span>
<span class="sd">    Returns:</span>
<span class="sd">      badEp:bool (X.shape axis==1) indicator for outlying elements</span>
<span class="sd">      epPower:float (X.shape axis==1) power used to identify bad</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#print(&quot;X={} ax={}&quot;.format(X.shape,axis))</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  
    <span class="c1">#print(&quot;power={}&quot;.format(power.shape))</span>
    <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">power</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">power</span><span class="p">[</span><span class="n">good</span><span class="p">])</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">power</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">badThresh</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">thresh</span><span class="o">*</span><span class="n">sigma</span>
        <span class="n">good</span><span class="p">[</span><span class="n">power</span> <span class="o">&gt;</span> <span class="n">badThresh</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">good</span> <span class="o">=</span> <span class="n">good</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">power</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># (nTrl, nEp)</span>
    <span class="c1">#print(&quot;good={}&quot;.format(good.shape))</span>
    <span class="n">bad</span> <span class="o">=</span> <span class="o">~</span><span class="n">good</span>
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bad&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bad</span><span class="o">.</span><span class="n">ravel</span><span class="p">())))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">bad</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span></div>

<div class="viewcode-block" id="linear_trend_tracker"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.linear_trend_tracker">[docs]</a><span class="k">class</span> <span class="nc">linear_trend_tracker</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; linear trend tracker with adaptive forgetting factor</span>
<span class="sd">    &quot;&quot;&quot;</span>   

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">halflife</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span><span class="n">int_err_halflife</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">K_int_err</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">a0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b0</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span><span class="o">/</span><span class="n">halflife</span><span class="p">)</span> <span class="k">if</span> <span class="n">halflife</span> <span class="k">else</span> <span class="o">.</span><span class="mi">99</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warmup_weight</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">**</span><span class="mi">20</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">);</span> <span class="c1"># &gt;20 points for warmup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">if</span> <span class="n">int_err_halflife</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">halflife</span><span class="p">:</span>
            <span class="n">int_err_halflife</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">halflife</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">int_err_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span><span class="o">/</span><span class="n">int_err_halflife</span><span class="p">)</span> <span class="k">if</span> <span class="n">int_err_halflife</span> <span class="k">else</span> <span class="o">.</span><span class="mi">999</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K_int_err</span> <span class="o">=</span> <span class="n">K_int_err</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a0</span> <span class="o">=</span> <span class="n">a0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b0</span> <span class="o">=</span> <span class="n">b0</span>

<div class="viewcode-block" id="linear_trend_tracker.reset"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.linear_trend_tracker.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_err</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_model</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Y0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sX</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sY</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sXX</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sYX</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sYY</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_model</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">b0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_err</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">int_err</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">abs_err</span><span class="o">=</span><span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">int_err_N</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="linear_trend_tracker.fit"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.linear_trend_tracker.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">keep_err</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">keep_err</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X0</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">Y0</span><span class="o">=</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> 
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="o">...</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="o">...</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X0</span> <span class="o">=</span> <span class="n">X</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y0</span> <span class="o">=</span> <span class="n">Y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">X0</span></div>

<div class="viewcode-block" id="linear_trend_tracker.transform"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.linear_trend_tracker.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Y</span>

        <span class="c1">#if np.all(X==self.Xlast) or np.all(Y==self.Ylast):</span>
        <span class="c1">#    return self.getY(X)</span>
        <span class="c1"># get our prediction for this point and use to track our prediction error</span>
        <span class="n">Yest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getY</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">err</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Y</span><span class="o">-</span><span class="n">Yest</span><span class="p">))</span>
  
        <span class="c1">## center x/y</span>
        <span class="c1"># N.B. be sure to do all the analysis in floating point to avoid overflow</span>
        <span class="n">cX</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">X0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">cY</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="c1"># update the 1st and 2nd order summary statistics </span>
        <span class="n">wght</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">**</span><span class="n">N</span>
        <span class="c1"># adaptive learning rate as function of integerated error</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_weight</span><span class="p">:</span>
            <span class="n">ptwght</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">int_err</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">int_err_N</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">K_int_err</span><span class="p">)</span> <span class="c1">#1/max(1,err) if self.N &gt; self.warmup_weight else 1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ptwght</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># adaptive learning rate as a function of the direction of the error...</span>
        <span class="c1">#if err &lt; 0:</span>
        <span class="c1">#    ptwght = ptwght*.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span>  <span class="o">=</span> <span class="n">wght</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span>   <span class="o">+</span> <span class="n">ptwght</span><span class="o">*</span><span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sY</span> <span class="o">=</span> <span class="n">wght</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sY</span>  <span class="o">+</span> <span class="n">ptwght</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cY</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sX</span> <span class="o">=</span> <span class="n">wght</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sX</span>  <span class="o">+</span> <span class="n">ptwght</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cX</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sYY</span><span class="o">=</span> <span class="n">wght</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sYY</span> <span class="o">+</span> <span class="n">ptwght</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cY</span><span class="o">*</span><span class="n">cY</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sYX</span><span class="o">=</span> <span class="n">wght</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sYX</span> <span class="o">+</span> <span class="n">ptwght</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cY</span><span class="o">*</span><span class="n">cX</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sXX</span><span class="o">=</span> <span class="n">wght</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sXX</span> <span class="o">+</span> <span class="n">ptwght</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cX</span><span class="o">*</span><span class="n">cX</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># update the slope when warmed up</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_weight</span><span class="p">:</span>
            <span class="n">Yvar</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sYY</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sY</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sY</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
            <span class="n">Xvar</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sXX</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sX</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sX</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
            <span class="n">YXvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sYX</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sY</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sX</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">YXvar</span> <span class="o">/</span> <span class="n">Xvar</span> <span class="o">+</span> <span class="n">Yvar</span><span class="o">/</span><span class="n">YXvar</span> <span class="p">)</span><span class="o">/</span><span class="mi">2</span>        
        <span class="c1"># update the bias given the estimated slope b = mu_y - a * mu_x</span>
        <span class="c1"># being sure to include the shift to the origin!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sY</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sX</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># check for steps in the inputs</span>
        <span class="c1"># get our prediction for this point and use to track our prediction error</span>
        <span class="n">Yest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getY</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">err</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Y</span><span class="o">-</span><span class="n">Yest</span><span class="p">)</span>

        <span class="c1"># track the prediction error, with long and short half-life</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abs_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abs_err</span><span class="o">*</span><span class="n">wght</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="c1"># track with step window</span>
        <span class="n">int_err_wght</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_err_alpha</span><span class="o">**</span><span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">int_err_N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_err_N</span> <span class="o">*</span> <span class="n">int_err_wght</span> <span class="o">+</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">int_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_err</span><span class="o">*</span><span class="n">int_err_wght</span> <span class="o">+</span> <span class="n">err</span>

        <span class="c1"># only return the estimate if we&#39;ve warmed up the tracker</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">warmup_weight</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Y</span>

        <span class="c1"># detect change in statistics by significant difference in error statistics</span>
        <span class="c1"># between long and short halflife</span>
        <span class="c1">#if (self.step_err / self.step_N) &gt; (self.err / self.N) * self.step_threshold:</span>
        <span class="c1">#    print(&quot;step-detected&quot;)</span>
        <span class="c1">#    #self.fit(X,Y,keep_err=True)</span>
        <span class="c1">#    #Yest = Y</span>

        <span class="k">return</span> <span class="n">Yest</span></div>

<div class="viewcode-block" id="linear_trend_tracker.getX"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.linear_trend_tracker.getX">[docs]</a>    <span class="k">def</span> <span class="nf">getX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">y</span>  <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> </div>

<div class="viewcode-block" id="linear_trend_tracker.getY"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.linear_trend_tracker.getY">[docs]</a>    <span class="k">def</span> <span class="nf">getY</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span></div>

<div class="viewcode-block" id="linear_trend_tracker.testcase"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.linear_trend_tracker.testcase">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">testcase</span><span class="p">():</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">1e6</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">/</span><span class="mi">50</span> 
        <span class="n">b</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Ytrue</span><span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">X</span><span class="o">+</span><span class="n">b</span>
        <span class="n">Y</span>    <span class="o">=</span> <span class="n">Ytrue</span><span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">Ytrue</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span>

        <span class="kn">import</span> <span class="nn">glob</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)),</span><span class="s1">&#39;../../logs/mindaffectBCI*.txt&#39;</span><span class="p">))</span> <span class="c1"># * means all if need specific format then *.csv</span>
        <span class="n">savefile</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getctime</span><span class="p">)</span>
        <span class="c1">#savefile = &quot;C:\\Users\\Developer\\Downloads\\mark\\mindaffectBCI_brainflow_200911_1339.txt&quot; </span>
        <span class="c1">#savefile = &quot;C:/Users/Developer/Downloads/khash/mindaffectBCI_brainflow_ipad_200908_1938.txt&quot;</span>
        <span class="kn">from</span> <span class="nn">mindaffectBCI.decoder.offline.read_mindaffectBCI</span> <span class="kn">import</span> <span class="n">read_mindaffectBCI_messages</span>
        <span class="kn">from</span> <span class="nn">mindaffectBCI.utopiaclient</span> <span class="kn">import</span> <span class="n">DataPacket</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">savefile</span><span class="p">))</span>
        <span class="n">msgs</span> <span class="o">=</span> <span class="n">read_mindaffectBCI_messages</span><span class="p">(</span><span class="n">savefile</span><span class="p">,</span><span class="n">regress</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="c1"># load without time-stamp fixing.</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span> <span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">msgs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">DataPacket</span><span class="p">)]</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">m</span><span class="o">.</span><span class="n">sts</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">dp</span><span class="p">])</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">nsc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">nsc</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ytrue</span> <span class="o">=</span> <span class="n">nsc</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">ltt</span> <span class="o">=</span> <span class="n">linear_trend_tracker</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
        <span class="n">ltt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># check scalar inputs</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">step</span><span class="p">))</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">) a=</span><span class="si">{}</span><span class="s2"> b=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;true&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
        <span class="n">dts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ltt</span><span class="o">.</span><span class="n">getY</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idxs</span><span class="p">):</span>
            <span class="n">dts</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">ltt</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">step</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">step</span><span class="p">])</span>
            <span class="n">ab</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ltt</span><span class="o">.</span><span class="n">a</span><span class="p">,</span><span class="n">ltt</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
            <span class="n">yest</span> <span class="o">=</span> <span class="n">ltt</span><span class="o">.</span><span class="n">getY</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">err</span> <span class="o">=</span>  <span class="n">yest</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">) argh! yest=</span><span class="si">{}</span><span class="s2"> ytrue=</span><span class="si">{}</span><span class="s2"> err=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">yest</span><span class="p">,</span><span class="n">Ytrue</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">err</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:4d}</span><span class="s2">) a=</span><span class="si">{:5f}</span><span class="s2"> b=</span><span class="si">{:5f}</span><span class="se">\t</span><span class="s2">y_est-y=</span><span class="si">{:2.5f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">ab</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">ab</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">yest</span><span class="p">))</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">ab</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span><span class="mi">1</span><span class="p">),</span><span class="n">Y</span><span class="p">,</span><span class="n">rcond</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ots</span> <span class="o">=</span> <span class="n">X</span><span class="o">*</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>        
        <span class="n">idx</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">*</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;server ts&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">dts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">*</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;regressed ts (samp vs server)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">ots</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">*</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;regressed ts (samp vs server) offline&#39;</span><span class="p">)</span>

        <span class="n">err</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">-</span> <span class="n">X</span><span class="o">*</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">err</span><span class="p">);</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="o">-</span><span class="n">cent</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">((</span><span class="n">cent</span><span class="o">-</span><span class="n">scale</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span><span class="n">cent</span><span class="o">+</span><span class="n">scale</span><span class="o">*</span><span class="mi">5</span><span class="p">))</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>
        

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">butter</span><span class="p">,</span> <span class="n">bessel</span><span class="p">,</span> <span class="n">sosfilt</span><span class="p">,</span> <span class="n">sosfilt_zi</span>
<span class="k">except</span><span class="p">:</span>
<span class="c1">#if True:</span>
    <span class="c1"># use the pure-python fallbacks</span>
    <span class="k">def</span> <span class="nf">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">axis</span><span class="p">,</span><span class="n">zi</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sosfilt_2d_py</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span><span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sosfilt_zi</span><span class="p">(</span><span class="n">sos</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sosfilt_zi_py</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">freq</span><span class="p">,</span><span class="n">btype</span><span class="p">,</span><span class="n">output</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">butter_py</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">freq</span><span class="p">,</span><span class="n">btype</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>

<div class="viewcode-block" id="sosfilt_zi_warmup"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.sosfilt_zi_warmup">[docs]</a><span class="k">def</span> <span class="nf">sosfilt_zi_warmup</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># no neg axis</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">+</span><span class="n">axis</span>
    <span class="c1"># zi =&gt; (order,...,2,...)</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="p">(</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="n">axis</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># make a programattic index expression to support arbitary axis</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span>
    <span class="c1"># get the index to start the warmup</span>
    <span class="n">warmupidx</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">sos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">sos</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># center on 1st warmup value</span>
    <span class="n">idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">warmupidx</span><span class="p">,</span><span class="n">warmupidx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">zi</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> 

    <span class="c1"># run the filter on the rest of the warmup values</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">warmupidx</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span> 
        <span class="n">idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">warmupidx</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">zi</span>  <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">zi</span></div>

<div class="viewcode-block" id="iir_sosfilt_sos"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.iir_sosfilt_sos">[docs]</a><span class="k">def</span> <span class="nf">iir_sosfilt_sos</span><span class="p">(</span><span class="n">stopband</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; given a set of filter cutoffs return butterworth sos coefficients &#39;&#39;&#39;</span>

    <span class="c1"># convert to normalized frequency, Note: not to close to 0/1</span>
    <span class="k">if</span> <span class="n">stopband</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stopband</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
        <span class="n">stopband</span><span class="o">=</span><span class="p">(</span><span class="n">stopband</span><span class="p">,)</span>

    <span class="n">sos</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">sb</span> <span class="ow">in</span> <span class="n">stopband</span><span class="p">:</span>
        <span class="n">btype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># convert to normalize frequency</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">sb</span><span class="p">[</span><span class="n">sb</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">sb</span><span class="p">[</span><span class="n">sb</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># neg freq count back from nyquist</span>
        <span class="n">Wn</span>  <span class="o">=</span> <span class="n">sb</span><span class="o">/</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span>  <span class="n">Wn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">0001</span> <span class="ow">or</span> <span class="o">.</span><span class="mi">9999</span> <span class="o">&lt;</span> <span class="n">Wn</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># no filter</span>
            <span class="k">continue</span>

        <span class="c1"># identify type from frequencies used, cliping if end of frequency range</span>
        <span class="k">if</span> <span class="n">Wn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">0001</span><span class="p">:</span>
            <span class="n">Wn</span> <span class="o">=</span> <span class="n">Wn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;highpass&#39;</span> <span class="k">if</span> <span class="n">btype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;bandstop&#39;</span> <span class="k">else</span> <span class="s1">&#39;lowpass&#39;</span>
        <span class="k">elif</span> <span class="o">.</span><span class="mi">9999</span> <span class="o">&lt;</span> <span class="n">Wn</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">Wn</span> <span class="o">=</span> <span class="n">Wn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;lowpass&#39;</span> <span class="k">if</span> <span class="n">btype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;bandstop&#39;</span> <span class="k">else</span> <span class="s1">&#39;highpass&#39;</span>

        <span class="k">elif</span> <span class="n">btype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># .001 &lt; Wn[0] and Wn[1] &lt; .999:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;bandstop&#39;</span>

        <span class="k">if</span> <span class="n">verb</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">=</span><span class="si">{}</span><span class="s2">=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">btype</span><span class="p">,</span><span class="n">sb</span><span class="p">,</span><span class="n">Wn</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;butter&#39;</span><span class="p">:</span>
            <span class="n">sosi</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="n">btype</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;bessel&#39;</span><span class="p">:</span>
            <span class="n">sosi</span> <span class="o">=</span> <span class="n">bessel</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="n">btype</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;phase&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognised filter type&quot;</span><span class="p">)</span>

        <span class="n">sos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sosi</span><span class="p">)</span>

    <span class="c1"># single big filter cascade</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sos</span></div>

<div class="viewcode-block" id="butter_sosfilt"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.butter_sosfilt">[docs]</a><span class="k">def</span> <span class="nf">butter_sosfilt</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">stopband</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; use a (cascade of) butterworth SOS filter(s) to band-pass and (cascade of) band stop X along axis &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">stopband</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># deal with no filter case</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># no neg axis</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">+</span><span class="n">axis</span>
    <span class="c1"># TODO []: auto-order determination?</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">iir_sosfilt_sos</span><span class="p">(</span><span class="n">stopband</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="n">passband</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">)</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># keep as single precision</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">sosfilt_zi</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span> <span class="c1"># (order,2)</span>
        <span class="n">zi</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">sosfilt_zi_warmup</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">sos</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: not warming up...&quot;</span><span class="p">)</span>

    <span class="c1"># Apply the warmed up filter to the input data</span>
    <span class="c1">#print(&quot;zi={}&quot;.format(zi.shape))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#print(&quot;filt:zi X{} axis={}&quot;.format(X.shape,axis))</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">zi</span>  <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;filt:no-zi&quot;</span><span class="p">)</span>
        <span class="n">X</span>  <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="c1"># zi=zi)</span>

    <span class="c1"># return filtered data, filter-coefficients, filter-state</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sos</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span></div>

<div class="viewcode-block" id="save_butter_sosfilt_coeff"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.save_butter_sosfilt_coeff">[docs]</a><span class="k">def</span> <span class="nf">save_butter_sosfilt_coeff</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stopband</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">25</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">fs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; design a butterworth sos filter cascade and save the coefficients &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">iir_sosfilt_sos</span><span class="p">(</span><span class="n">stopband</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fytpe</span><span class="o">=</span><span class="n">ftype</span><span class="p">)</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">sosfilt_zi</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># auto-generate descriptive filename</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_stopband</span><span class="si">{}</span><span class="s2">_fs</span><span class="si">{}</span><span class="s2">.pk&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">btype</span><span class="p">,</span><span class="n">stopband</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="test_butter_sosfilt"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.test_butter_sosfilt">[docs]</a><span class="k">def</span> <span class="nf">test_butter_sosfilt</span><span class="p">():</span>
    <span class="n">fs</span><span class="o">=</span> <span class="mi">100</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">fs</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="mi">100</span> <span class="c1"># include start shift</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">();</span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">511</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>

    <span class="n">pbs</span><span class="o">=</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">40</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)),(</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),((</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">),(</span><span class="mi">45</span><span class="p">,</span><span class="mi">50</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">pb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pbs</span><span class="p">):</span>
        <span class="n">Xf</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">butter_sosfilt</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">pb</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Xf</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pb</span><span class="p">))</span>

    <span class="c1"># test incremental application</span>
    <span class="n">pb</span><span class="o">=</span><span class="n">pbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sos</span><span class="o">=</span><span class="kc">None</span>
    <span class="n">zi</span> <span class="o">=</span><span class="kc">None</span>
    <span class="n">Xf</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># init filter and do 1st block</span>
            <span class="n">Xfi</span><span class="p">,</span><span class="n">sos</span><span class="p">,</span><span class="n">zi</span> <span class="o">=</span> <span class="n">butter_sosfilt</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">fs</span><span class="p">,:],</span><span class="n">pb</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># incremenally apply</span>
            <span class="n">Xfi</span><span class="p">,</span><span class="n">zi</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">fs</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span><span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">)</span>
        <span class="n">Xf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Xfi</span><span class="p">)</span>
    <span class="n">Xf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">Xf</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Xf</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> - incremental&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pb</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># test diff specifications</span>
    <span class="n">pb</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">40</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># pair stops</span>
    <span class="n">Xf0</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">butter_sosfilt</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">pb</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Xf0</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pb</span><span class="p">))</span>
 
    <span class="n">pb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="s1">&#39;bandpass&#39;</span><span class="p">)</span> <span class="c1"># single pass</span>
    <span class="n">Xfi</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">butter_sosfilt</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">pb</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Xfi</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pb</span><span class="p">))</span>

    <span class="n">pb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="s1">&#39;bandpass&#39;</span><span class="p">)</span> <span class="c1"># single pass</span>
    <span class="n">Xfi</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">butter_sosfilt</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">pb</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span><span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;bessel&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Xfi</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> - bessel&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pb</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<span class="c1"># TODO[] : cythonize?</span>
<span class="c1"># TODO[X] : vectorize over d? ---- NO. 2.5x *slower*</span>
<div class="viewcode-block" id="sosfilt_2d_py"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.sosfilt_2d_py">[docs]</a><span class="k">def</span> <span class="nf">sosfilt_2d_py</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span><span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; pure python fallback for second-order-sections filter in case scipy isn&#39;t available &#39;&#39;&#39;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">returnzi</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">returnzi</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>

    <span class="n">Xshape</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: X&gt;2d.... treating as 2d...&quot;</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Xshape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only for time in dim 0/-2&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sos</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sos must be shape (n_sections, 6)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;zi must be shape (n_sections, 2, dim)&#39;</span><span class="p">)</span>

    <span class="c1"># pre-normalize sos if needed</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">sos</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">sos</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">sos</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">/</span><span class="n">sos</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
    
    <span class="n">n_signals</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_sections</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># extract the a/b</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sos</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sos</span><span class="p">[:,</span><span class="mi">4</span><span class="p">:]</span>

    <span class="c1"># loop over outputs</span>
    <span class="n">x_n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_signals</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sections</span><span class="p">):</span>
                <span class="n">x_n</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="c1"># use direct II transposed structure</span>
                <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_n</span> <span class="o">+</span> <span class="n">zi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">zi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_n</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">zi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">zi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_n</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

    <span class="c1"># back to input shape</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">Xshape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Xshape</span><span class="p">)</span>

    <span class="c1"># match sosfilt, only return zi if given zi</span>
    <span class="k">if</span> <span class="n">returnzi</span> <span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">zi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span></div>

<div class="viewcode-block" id="sosfilt_zi_py"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.sosfilt_zi_py">[docs]</a><span class="k">def</span> <span class="nf">sosfilt_zi_py</span><span class="p">(</span><span class="n">sos</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; compute an initial state for a second-order section filter &#39;&#39;&#39;</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sos</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sos must be shape (n_sections, 6)&#39;</span><span class="p">)</span>

    <span class="n">n_sections</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_sections</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sections</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="c1"># Normalize the coefficients so a[0] == 1.</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">IminusA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">linalg</span><span class="o">.</span><span class="n">companion</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Solve zi = A*zi + B</span>
        <span class="n">lfitler_zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">IminusA</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="n">zi</span><span class="p">[</span><span class="n">section</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">lfilter_zi</span>
        <span class="n">scale</span> <span class="o">*=</span> <span class="n">b</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">zi</span></div>

<div class="viewcode-block" id="test_sosfilt_py"><a class="viewcode-back" href="../../../mindaffectBCI.decoder.html#mindaffectBCI.decoder.utils.test_sosfilt_py">[docs]</a><span class="k">def</span> <span class="nf">test_sosfilt_py</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;butter_stopband((0, 5), (25, -1))_fs200.pk&#39;</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">sos</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X=</span><span class="si">{}</span><span class="s2"> sos=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="n">Xsci</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Xpy</span> <span class="o">=</span> <span class="n">sosfilt_2d_py</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span><span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">();</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">411</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="mi">500</span><span class="p">,:]);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">412</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Xsci</span><span class="p">[:</span><span class="mi">500</span><span class="p">,:]);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Xscipy&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">413</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Xpy</span><span class="p">[:</span><span class="mi">500</span><span class="p">,:]);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Xpy&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">414</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Xsci</span><span class="o">-</span><span class="n">Xpy</span><span class="p">);</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Xsci - Xpy&#39;</span><span class="p">)</span></div>

<span class="c1"># def butter_py(order,fc,fs,btype,output):</span>
<span class="c1">#     &#39;&#39;&#39; pure python butterworth filter synthesis &#39;&#39;&#39;</span>
<span class="c1">#     if fc&gt;=fs/2:</span>
<span class="c1">#         error(&#39;fc must be less than fs/2&#39;)</span>

<span class="c1">#     # I.  Find poles of analog filter</span>
<span class="c1">#     k= np.arange(order)</span>
<span class="c1">#     theta= (2*k -1)*np.pi/(2*order);</span>
<span class="c1">#     pa= -sin(theta) + j*cos(theta);     # poles of filter with cutoff = 1 rad/s</span>
<span class="c1">#     #</span>
<span class="c1">#     # II.  scale poles in frequency</span>
<span class="c1">#     Fc= fs/np.pi * tan(np.pi*fc/fs);          # continuous pre-warped frequency</span>
<span class="c1">#     pa= pa*2*np.pi*Fc;                     # scale poles by 2*pi*Fc</span>
<span class="c1">#     #</span>
<span class="c1">#     # III.  Find coeffs of digital filter</span>
<span class="c1">#     # poles and zeros in the z plane</span>
<span class="c1">#     p= (1 + pa/(2*fs))/(1 - pa/(2*fs))      # poles by bilinear transform</span>
<span class="c1">#     q= -np.ones((1,N));                   # zeros</span>
<span class="c1">#     #</span>
<span class="c1">#     # convert poles and zeros to polynomial coeffs</span>
<span class="c1">#     a= poly(p);                   # convert poles to polynomial coeffs a</span>
<span class="c1">#     a= real(a);</span>
<span class="c1">#     b= poly(q);                   # convert zeros to polynomial coeffs b</span>
<span class="c1">#     K= sum(a)/sum(b);             # amplitude scale factor</span>
<span class="c1">#     b= K*b;    </span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_butter_sosfilt</span><span class="p">()</span>
    <span class="n">linear_trend_tracker</span><span class="o">.</span><span class="n">testcase</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Mark van Kesteren

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>